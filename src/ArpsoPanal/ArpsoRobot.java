package ArpsoPanal;import SuperPack.AbstractAgentPanel.AgentRobot;import SuperPack.Panel.Intelligence;import SuperPack.Panel.Point2;import SuperPack.Panel.SimulationPanel;import java.util.Map;/** * Created by Ishiwatari on 2016/11/01. */public class ArpsoRobot extends AgentRobot {    Intelligence oldPI;    //alpha>beta それぞれ[0,1]    private final static double alpha = 0.4;    private final static double beta = 0.8;    private int time = 0;//前回捕まえてからの時間    protected ArpsoRobot(SimulationPanel as) {        super(as);        oldPI = new Intelligence(PI);        time = 0;    }    protected ArpsoRobot(Point2 point, SimulationPanel s) {        super(point, s);        oldPI = new Intelligence(PI);        time = 0;    }    protected ArpsoRobot(SimulationPanel s, String robotString) {        super(s, robotString);        oldPI = new Intelligence(PI);        time = 0;    }    public void reset(Point2 p) {        super.reset(p);        time = 0;    }    /**     * A-RDPSOによって速度を決定する     *     * @return     */    @Override    protected Point2 calVelocity() {        CI = getGlobalBest();        PI = getPersonalBest();        //ARPSOに必要な式を計算        double evolSpeed = 1.0 - (PI.getFitnessValue() / oldPI.getFitnessValue());        double degree = getGlobalBest().getFitnessValue() / getAverageFitenessValue();        double maxTime = (double) field.maxCount / (double) field.targetList.size();        double weightT = time / maxTime > 1 ? 1.0 : time / maxTime;        double inertiaWeight = PI.getFitnessValue() <= CI.getFitnessValue() ?                2.0 - (2.0 - 1.0 / 2.0) * weightT : 1.0;        //omega,c2の決定        double omega = inertiaWeight * (1 - alpha * evolSpeed + beta * degree);        c2 = intelligenceHashMap.size() * 0.4 + c1 < 2 * c1 ? intelligenceHashMap.size() * 0.4 + c1 : c1 * 2;        //ARPSOに従って動かす        Point2 v = new Point2(this.v.x * omega + c1 * Math.random() * (PI.x - p.x) + c2 * Math.random() * (CI.x - p.x),                this.v.y * omega + c1 * Math.random() * (PI.y - p.y) + c2 * Math.random() * (CI.y - p.y));        oldPI = new Intelligence(PI);        if (id == field.debugMode) {            System.out.println("----------id: " + id + "------------");            System.out.println("v( " + v.x + ", " + v.y + ")");            System.out.println("oldPI= " + oldPI.getFitnessValue());            System.out.println("omega " + omega + "/C1 " + c1 + "/c2 " + c2);            System.out.println("PI " + PI.getFitnessValue() + "/CI " + CI.getFitnessValue() + "/Fitness " + fitnessFunction(field.targetList));            System.out.println("21 /evolS " + evolSpeed + "/degree " + degree + "/y " + inertiaWeight + "/omega " + omega);        }        time++;        return v;    }    private double getAverageFitenessValue() {        double sum = 0.0;        for (Map.Entry<Integer, Intelligence> entry : intelligenceHashMap.entrySet()) {            Intelligence i = entry.getValue();            sum += i.getFitnessValue();        }        return sum / intelligenceHashMap.size();    }    @Override    protected void captured() {        //FIXME デバック用        super.captured();        time = 0;    }}